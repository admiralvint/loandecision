import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import tkinter.font as tkfont
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import csv
import copy
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Tuple, Optional, Any
import io # For specific IO errors
import traceback # Import for debugging tracebacks

# -----------------------------
# CONSTANTS
# -----------------------------
PROCESSING_FEE: float = 3000.0
DIVIDEND_TAX_RATE: float = 0.22 # Estonian income tax on dividends (approx)

# Default Input Values
DEFAULT_PROP_VALUE: str = "391000"
DEFAULT_PROP_GROWTH: str = "3"
DEFAULT_INIT_OWN: str = "58650"
DEFAULT_ADD_OWN: str = "100000"
DEFAULT_DURATION: str = "30"
DEFAULT_ANNUAL_RATE: str = "3.5"
DEFAULT_ETF_INITIAL: str = "100000"
DEFAULT_ETF_GROWTH_FULL: str = "7" # Scenario 2
DEFAULT_ETF_GROWTH_DIV: str = "5"  # Scenario 3
DEFAULT_ETF_DIVIDEND: str = "2"

# -----------------------------
# DATA STRUCTURE FOR RESULTS
# -----------------------------
@dataclass
class SimulationResult:
    Year: int
    PropertyValue: float = 0.0
    LoanBalance: float = 0.0
    MonthlyPayment: float = 0.0
    AnnualInterest: float = 0.0
    ETFValue: float = 0.0
    ETFGrowth: float = 0.0       # Capital growth component of ETF value change
    GrossDividend: float = 0.0   # Yearly gross dividend generated by ETF
    DividendIncome: float = 0.0  # Net dividend used for loan repayment (Scen 3 only)
    NetEquity: float = 0.0
    TotalInterest: Optional[float] = field(default=None, compare=False) # Stored only in last entry

# Type alias for clarity
ScenarioResults = List[SimulationResult]

# -----------------------------
# FINANCIAL HELPER FUNCTIONS
# -----------------------------
def pmt(annual_rate: float, n_years: float, principal: float) -> float:
    """Calculate the monthly payment using the annuity formula."""
    if principal <= 0 or n_years <= 0: # Ensure positive principal and duration
        return 0.0
    monthly_rate = annual_rate / 100 / 12
    n_months = n_years * 12
    if monthly_rate == 0:
        return principal / n_months # Straight line principal reduction if rate is zero
    try:
        # Standard annuity formula
        payment = principal * (monthly_rate * (1 + monthly_rate) ** n_months) / (((1 + monthly_rate) ** n_months) - 1)
    except OverflowError:
        messagebox.showerror("Calculation Error", "Overflow occurred calculating monthly payment. Check inputs (rate/duration too high?).")
        return float('inf') # Indicate an error state
    except ZeroDivisionError:
         # Should be caught by rate=0 check, but for safety
         return float('inf')
    return payment

def remaining_balance(principal: float, annual_rate: float, total_years: float, elapsed_years: float) -> float:
    """Calculate the remaining loan balance after elapsed_years using financial formula."""
    if principal <= 0 or total_years <= 0: # Ensure positive principal and total duration
        return 0.0
    monthly_rate = annual_rate / 100 / 12
    n = total_years * 12 # Total months
    m = elapsed_years * 12 # Elapsed months
    if m >= n : return 0.0 # Balance is 0 if elapsed time is >= total time


    if monthly_rate == 0:
        # Handle zero interest rate case - linear reduction
        return principal * (1 - m/n) if n > 0 else principal # Should not happen due to n > 0 check

    try:
        # Formula for remaining balance of an annuity
        numerator = (1 + monthly_rate) ** n - (1 + monthly_rate) ** m
        denominator = ((1 + monthly_rate) ** n) - 1
        if denominator == 0: # This indicates an issue with rate=0 or n=0, already handled
             return principal # Fallback

        balance = principal * (numerator / denominator)
    except OverflowError:
        messagebox.showerror("Calculation Error", "Overflow occurred calculating remaining balance. Check inputs.")
        return float('inf') # Indicate an error state
    return max(0.0, balance) # Ensure balance doesn't go negative due to float issues

def property_value(initial_value: float, growth_percent: float, years: int) -> float:
    """Calculate the property value after a given number of years."""
    if years < 0: return initial_value # Value doesn't decrease for negative years
    return initial_value * ((1 + growth_percent / 100) ** years)

# -----------------------------
# SIMULATION FUNCTIONS
# -----------------------------
def simulate_scenario_1(loan_years: float, prop0: float, prop_growth: float, full_loan: float, add_own: float, annual_rate: float) -> ScenarioResults:
    """
    Scenario 1: Loan reduction via a one‑time additional payment.
    Effective loan = full_loan - add_own. ETF values are 0.
    """
    effective_loan = max(0.0, full_loan - add_own) # Ensure non-negative loan
    # If effective loan is 0, no simulation years related to loan are needed.
    # Simulation should still track property growth for the specified loan_years duration.
    simulation_duration_years = int(loan_years) # Always simulate for the input duration

    # Only calculate payment if there is an initial effective loan
    fixed_payment = pmt(annual_rate, loan_years, effective_loan)

    results: ScenarioResults = []
    total_interest: float = 0.0

    current_loan_balance = effective_loan
    for year in range(1, simulation_duration_years + 1):
        pv = property_value(prop0, prop_growth, year)

        # Only calculate loan-specific values if there was an effective loan initially
        lb_end_year = 0.0
        annual_int = 0.0
        monthly_payment_this_year = 0.0

        if effective_loan > 0:
             # Calculate remaining balance based on original effective loan and total duration
            lb_end_year = remaining_balance(effective_loan, annual_rate, loan_years, year)
            lb_begin_year = current_loan_balance # Use tracked balance from previous year/start

            # Estimate annual interest based on average balance for this scenario
            # This is an approximation for display; actual loan amortization is more complex.
            # For simplicity here, we use the average balance method.
            avg_balance = (lb_begin_year + lb_end_year) / 2
            annual_int = avg_balance * (annual_rate / 100) # Interest for this year
            total_interest += annual_int

            # Monthly payment applies as long as there is still a balance at the start of the period
            monthly_payment_this_year = fixed_payment if lb_begin_year > 1e-2 else 0.0
        else:
             # If effective loan was 0 initially, loan_balance is always 0
             lb_end_year = 0.0
             annual_int = 0.0
             monthly_payment_this_year = 0.0


        net_equity = pv - lb_end_year

        results.append(SimulationResult(
            Year=year,
            PropertyValue=pv,
            LoanBalance=lb_end_year,
            MonthlyPayment=monthly_payment_this_year,
            AnnualInterest=annual_int,
            ETFValue=0.0,
            ETFGrowth=0.0,
            GrossDividend=0.0,
            DividendIncome=0.0,
            NetEquity=net_equity
        ))
        # Update current balance for the next year's calculation (only relevant if effective_loan > 0)
        if effective_loan > 0:
            current_loan_balance = lb_end_year


    # Add total interest to the last record (if any records exist)
    if results:
        # If loan was paid off early due to add_own, total interest is calculated over the
        # years the loan was active. The current_loan_balance tracking helps, but
        # remaining_balance formula gives the exact year-end balance.
        # The annual_int calculation sums up yearly interest correctly based on these.
        results[-1].TotalInterest = total_interest
    # If no results (e.g., simulation_duration_years=0), return empty list
    return results


def simulate_scenario_2(loan_years: float, prop0: float, prop_growth: float, full_loan: float, annual_rate: float, etf_initial: float, etf_growth: float, dividend_yield: float) -> ScenarioResults:
    """
    Scenario 2: ETF reinvestment (full loan is used).
    Dividends are automatically reinvested. Combined growth factor used.
    Calculates and stores Gross Dividend generated yearly.
    """
    effective_loan = max(0.0, full_loan)
    simulation_duration_years = int(loan_years) # Always simulate for the input duration

    # Only calculate payment if there is an initial effective loan
    fixed_payment = pmt(annual_rate, loan_years, effective_loan)

    results: ScenarioResults = []
    total_interest: float = 0.0
    # Combined factor includes capital growth and dividend yield for reinvestment
    # Ensure rates are handled correctly as percentages
    combined_factor = (1 + etf_growth / 100.0) * (1 + dividend_yield / 100.0)

    current_loan_balance = effective_loan
    current_etf_value = etf_initial # Track ETF value iteratively

    for year in range(1, simulation_duration_years + 1):
        pv = property_value(prop0, prop_growth, year)

        # Only calculate loan-specific values if there was an effective loan initially
        lb_end_year = 0.0
        annual_int = 0.0
        monthly_payment_this_year = 0.0

        if effective_loan > 0:
            lb_end_year = remaining_balance(effective_loan, annual_rate, loan_years, year)
            lb_begin_year = current_loan_balance

            # Estimate annual interest based on average balance
            avg_balance = (lb_begin_year + lb_end_year) / 2
            annual_int = avg_balance * (annual_rate / 100.0) # Interest for this year
            total_interest += annual_int

            # Monthly payment applies as long as there is still a balance at the start of the period
            monthly_payment_this_year = fixed_payment if lb_begin_year > 1e-2 else 0.0
        else:
            lb_end_year = 0.0
            annual_int = 0.0
            monthly_payment_this_year = 0.0


        # Calculate ETF Value and Growth for the year
        # ETF grows based on the value at the *start* of the year (current_etf_value)
        gross_dividend_this_year = current_etf_value * (dividend_yield / 100.0)
        capital_growth_amount = current_etf_value * (etf_growth / 100.0)

        # Update ETF value for the end of the year (growth + reinvested dividends)
        current_etf_value += capital_growth_amount + gross_dividend_this_year

        net_equity = pv - lb_end_year + current_etf_value

        results.append(SimulationResult(
            Year=year,
            PropertyValue=pv,
            LoanBalance=lb_end_year,
            MonthlyPayment=monthly_payment_this_year,
            AnnualInterest=annual_int,
            ETFValue=current_etf_value,
            ETFGrowth=capital_growth_amount, # Storing only capital growth here
            GrossDividend=gross_dividend_this_year,
            DividendIncome=0.0, # Reinvested, not used elsewhere
            NetEquity=net_equity
        ))
        # Update current balance for the next year's calculation (only relevant if effective_loan > 0)
        if effective_loan > 0:
             current_loan_balance = lb_end_year


    # Add total interest to the last record
    if results:
        results[-1].TotalInterest = total_interest
    return results

def simulate_scenario_3(loan_years: float, prop0: float, prop_growth: float, full_loan: float, annual_rate: float, etf_initial: float, etf_growth: float, dividend_yield: float) -> ScenarioResults:
    """
    Scenario 3: ETF dividend-based loan reduction, switching to reinvestment.
    Net ETF dividend (after tax) reduces loan balance annually until loan is paid off.
    After loan payoff, gross dividends are reinvested into the ETF.
    ETF principal grows via etf_growth rate yearly.
    Annual Interest is calculated accurately by summing monthly interest.
    Calculates and stores Gross Dividend generated yearly.
    """
    effective_loan = max(0.0, full_loan)
    if effective_loan <= 1e-2: # If effective loan is zero or negligible, no simulation needed
         simulation_duration_years = int(loan_years) # Still simulate property/ETF growth
         # Create results for ETF/property growth even if no loan
         results_no_loan: ScenarioResults = []
         current_etf_value_no_loan = etf_initial
         etf_growth_rate = etf_growth / 100.0
         dividend_rate = dividend_yield / 100.0

         for year in range(1, simulation_duration_years + 1):
             pv = property_value(prop0, prop_growth, year)
             # Reinvest scenario for ETF if no loan
             capital_growth_amount = current_etf_value_no_loan * etf_growth_rate
             gross_dividend = current_etf_value_no_loan * dividend_rate
             current_etf_value_no_loan += capital_growth_amount + gross_dividend # Reinvest

             results_no_loan.append(SimulationResult(
                 Year=year,
                 PropertyValue=pv,
                 LoanBalance=0.0,
                 MonthlyPayment=0.0,
                 AnnualInterest=0.0,
                 ETFValue=current_etf_value_no_loan,
                 ETFGrowth=capital_growth_amount,
                 GrossDividend=gross_dividend,
                 DividendIncome=0.0,
                 NetEquity=pv + current_etf_value_no_loan, # Net equity includes ETF value
                 TotalInterest=0.0 # No loan, no interest
             ))
         if results_no_loan: results_no_loan[-1].TotalInterest = 0.0
         return results_no_loan


    # --- Simulation with active loan ---
    total_months = int(loan_years * 12)
    fixed_payment = pmt(annual_rate, loan_years, effective_loan)
    monthly_rate = annual_rate / 100.0 / 12.0
    current_balance = effective_loan
    results: ScenarioResults = []
    total_interest: float = 0.0 # Cumulative interest over the life of the loan
    monthly_interest_accumulator: float = 0.0 # Accumulates interest within a year
    current_etf_value_iter = etf_initial # Track ETF value iteratively, start of year
    etf_growth_rate = etf_growth / 100.0
    dividend_rate = dividend_yield / 100.0
    net_dividend_multiplier = 1 - DIVIDEND_TAX_RATE

    loan_paid_off = False
    last_recorded_year = 0 # To track the last year simulation was run

    # Simulate month by month to accurately track loan balance reduction by dividends
    for month in range(1, total_months + 1):
        # Monthly loan calculations only proceed if loan is not paid off
        interest_this_month = 0.0
        principal_paid_by_payment = 0.0 # Principal from fixed payment

        if not loan_paid_off and current_balance > 1e-2: # Use tolerance
            interest_this_month = current_balance * monthly_rate
            monthly_interest_accumulator += interest_this_month

            principal_paid_by_payment = fixed_payment - interest_this_month
            # Ensure principal payment doesn't overshoot balance
            principal_paid_by_payment = min(principal_paid_by_payment, current_balance)
            current_balance -= principal_paid_by_payment

            if current_balance <= 1e-2: # Check after monthly payment
                current_balance = 0.0
                loan_paid_off = True


        # Yearly calculations (performed at the end of each year, month % 12 == 0)
        if month % 12 == 0:
            year = month // 12
            last_recorded_year = year

            # --- ETF Calculations ---
            # These are based on the ETF value at the START of the year (`current_etf_value_iter`)
            capital_growth_amount = current_etf_value_iter * etf_growth_rate
            gross_dividend = current_etf_value_iter * dividend_rate

            # Value after capital growth, before considering dividend action for this year
            etf_value_after_growth = current_etf_value_iter + capital_growth_amount

            # --- Dividend Action ---
            net_dividend_used_for_loan = 0.0
            etf_value_end_year = etf_value_after_growth # Start with value after growth

            if not loan_paid_off:
                # Use net dividend to pay loan
                net_dividend = gross_dividend * net_dividend_multiplier
                net_dividend_used_for_loan = min(net_dividend, current_balance) # Don't pay more than balance
                current_balance -= net_dividend_used_for_loan # Reduce loan balance by dividend

                # Check AGAIN if loan is paid off *after* dividend application
                if current_balance <= 1e-2:
                    current_balance = 0.0
                    loan_paid_off = True
                    # If paid off by dividend, ETF dividends are NOT reinvested THIS year.
                    # Reinvestment starts from NEXT year. ETF value remains etf_value_after_growth.
                    etf_value_end_year = etf_value_after_growth
                else:
                    # Loan is not paid off yet, dividends are used for loan, not reinvested
                    etf_value_end_year = etf_value_after_growth

            else: # Loan is already paid off at the start of this year's calculations
                 # Reinvest the gross dividend
                 etf_value_end_year = etf_value_after_growth + gross_dividend
                 net_dividend_used_for_loan = 0.0 # Not used for loan anymore

            # --- Property Value & Net Equity ---
            pv = property_value(prop0, prop_growth, year)
            net_equity = pv - current_balance + etf_value_end_year

            # --- Store Results ---
            results.append(SimulationResult(
                Year=year,
                PropertyValue=pv,
                LoanBalance=current_balance,
                # Monthly payment is applicable only if loan had a balance at the start of any month this year
                # or if the final payment occurred this year. This is complex to track precisely per year summary.
                # Let's show the fixed payment amount as long as the loan is not fully paid off.
                # If paid off this year, perhaps show the final partial payment?
                # For simplicity in yearly summary, show fixed payment if loan was active this year.
                # A more accurate summary would sum up actual monthly payments within the year.
                # Let's just show the fixed payment value if loan was active at the start of the year.
                # If loan is paid off mid-year, the total payments for the year are less than 12 * fixed_payment.
                # The annual summary isn't perfectly accurate for mid-year payoffs with this approach.
                # However, showing the fixed payment amount is common in summaries.
                MonthlyPayment=fixed_payment if current_balance > 1e-2 or not loan_paid_off else 0.0, # Show fixed pmt if loan active or just paid off
                AnnualInterest=monthly_interest_accumulator,
                ETFValue=etf_value_end_year,
                ETFGrowth=capital_growth_amount, # Capital growth part
                GrossDividend=gross_dividend,
                DividendIncome=net_dividend_used_for_loan, # Net amount used for loan
                NetEquity=net_equity
            ))

            # --- Update for Next Year ---
            current_etf_value_iter = etf_value_end_year # Set start value for next year
            total_interest += monthly_interest_accumulator # Add yearly interest to cumulative total
            monthly_interest_accumulator = 0.0 # Reset for next year'


    # --- Fill Remaining Years (if loan paid off early before total_months) ---
    # If the loop finished because all months were simulated (loan_paid_off is True),
    # this block is skipped. If the loop finished because loan_paid_off became True
    # before total_months, last_recorded_year < loan_years.
    etf_value_for_fill = current_etf_value_iter # This holds the value at the end of the last simulated year
    etf_growth_rate = etf_growth / 100.0 # Re-get rates as floats
    dividend_rate = dividend_yield / 100.0

    # Ensure we start filling from the year *after* the last one recorded
    start_fill_year = last_recorded_year + 1
    end_fill_year = int(loan_years) # Simulate up to the original loan duration

    # Only fill if the loan was paid off *before* the full term
    if loan_paid_off and start_fill_year <= end_fill_year:
         for year in range(start_fill_year, end_fill_year + 1):
            pv = property_value(prop0, prop_growth, year)

            # ETF continues to grow and dividends are reinvested (as loan is paid off)
            capital_growth_amount = etf_value_for_fill * etf_growth_rate
            gross_dividend = etf_value_for_fill * dividend_rate
            etf_value_for_fill += capital_growth_amount + gross_dividend # Apply growth and reinvested dividend

            net_equity = pv + etf_value_for_fill # Loan balance is 0

            results.append(SimulationResult(
                Year=year,
                PropertyValue=pv,
                LoanBalance=0.0, # Definitely 0 now
                MonthlyPayment=0.0, # No loan payment
                AnnualInterest=0.0, # No loan interest
                ETFValue=etf_value_for_fill,
                ETFGrowth=capital_growth_amount, # Capital growth part
                GrossDividend=gross_dividend,
                NetEquity=net_equity,
                DividendIncome=0.0 # Not used for loan anymore
            ))


    # Add total interest to the last record (which might be in the filled years if loan paid off early)
    if results:
        results[-1].TotalInterest = total_interest

    return results


# -----------------------------
# GUI USING TKINTER
# -----------------------------
class LoanDecisionGUI:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("Laenu ja investeeringu otsustusprogramm")
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)

        # Stores results for the current calculation session: {Scenario Name: List[SimulationResult]}
        self.session_results: Dict[str, List[SimulationResult]] = {} # Corrected type hint

        # --- Initialize Tkinter variables for input fields ---
        # This is where the loan_years StringVar must be initialized
        self.loan_years = tk.StringVar()
        # Initialize other StringVars for inputs that use _add_input_row
        self.sv_prop0 = tk.StringVar(value=DEFAULT_PROP_VALUE)
        self.sv_prop_growth = tk.StringVar(value=DEFAULT_PROP_GROWTH)
        self.sv_init_own = tk.StringVar(value=DEFAULT_INIT_OWN)
        self.sv_add_own = tk.StringVar(value=DEFAULT_ADD_OWN)
        self.sv_annual_rate = tk.StringVar(value=DEFAULT_ANNUAL_RATE)
        self.sv_etf_initial = tk.StringVar(value=DEFAULT_ETF_INITIAL)
        self.sv_etf_growth_full = tk.StringVar(value=DEFAULT_ETF_GROWTH_FULL)
        self.sv_etf_growth_div = tk.StringVar(value=DEFAULT_ETF_GROWTH_DIV)
        self.sv_etf_dividend = tk.StringVar(value=DEFAULT_ETF_DIVIDEND)

        # Set default value for loan_years StringVar AFTER initialization
        try:
             self.loan_years.set(str(DEFAULT_DURATION))
        except NameError:
             self.loan_years.set("30") # Set a fallback default
        # --- End StringVar Initialization ---


        # --- Main Frame ---
        self.main_frame = ttk.Frame(self.root, padding="10")
        self.main_frame.grid(row=0, column=0, sticky="nsew")
        self.main_frame.rowconfigure(1, weight=1) # Output frame should expand vertically
        self.main_frame.columnconfigure(0, weight=1) # Input/Output frames expand horizontally

        # --- Input Frame ---
        self.input_frame = ttk.LabelFrame(self.main_frame, text="Sisendid", padding="10")
        self.input_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        self.input_frame.columnconfigure(1, weight=1) # Make entry column expandable

        # --- Output Frame ---
        self.output_frame = ttk.LabelFrame(self.main_frame, text="Tulemused", padding="10")
        self.output_frame.grid(row=1, column=0, padx=5, pady=(5, 5), sticky="nsew")
        self.output_frame.rowconfigure(0, weight=1) # Text area row
        self.output_frame.rowconfigure(1, weight=3) # Graph area row (takes more space)
        self.output_frame.columnconfigure(0, weight=1) # Both take full width

        # Dictionary to potentially store references to Entry widgets, though using StringVars is preferred
        # if the main goal is just getting the value. We'll rely on StringVars now.
        # self.entries: Dict[str, ttk.Entry] = {}

        # Call the methods to create widgets.
        # The loan years entry creation MUST happen INSIDE create_input_widgets now.
        self.create_input_widgets()
        self.create_output_widgets()

        # --- REMOVE ANY CODE HERE THAT CREATES OR GRIDS loan_years_entry ---
        # Based on the previous snippet, these lines might have been here.
        # Example of code to remove if it exists here:
        # loan_years_entry = ttk.Entry(self.input_frame, textvariable=self.loan_years) # Remove this line
        # loan_years_entry.grid(row=some_row, column=1, padx=5, pady=5, sticky="ew") # Remove this line
        # --- End Removal ---


    def _add_input_row(self, label_text: str, string_var: tk.StringVar, row: int):
        """Helper to add a label and entry row linked to a StringVar."""
        ttk.Label(self.input_frame, text=label_text).grid(row=row, column=0, sticky="w", padx=5, pady=2)
        entry = ttk.Entry(self.input_frame, textvariable=string_var) # Link textvariable
        # Default value is set on the StringVar, no need to insert(0, ...) here
        entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)
        # If you still need the entry widget object itself, you could store it:
        # self.entries[label_text] = entry # Or use a key derived from label_text


    def create_input_widgets(self):
        """Creates and lays out the input widgets."""
        row = 0
        # Use the updated helper, passing the StringVar
        self._add_input_row("Kinnisvara algväärtus (€):", self.sv_prop0, row); row += 1
        self._add_input_row("Kinnisvara aastane kasv (%):", self.sv_prop_growth, row); row += 1
        self._add_input_row("Sissemakstud omafinantseering (€):", self.sv_init_own, row); row += 1
        self._add_input_row("Lisatud omafinantseering (€):", self.sv_add_own, row); row += 1

        # --- Handle Loan Duration Entry Separately to link its specific StringVar ---
        # Do NOT call _add_input_row for this one if the helper doesn't pass the correct textvariable
        # The updated helper DOES pass the StringVar, so we can potentially use it.
        # Let's update the helper slightly to include a key parameter if self.entries is still desired.
        # OR, if self.loan_years is unique, create it explicitly here.
        # Given self.loan_years was the source of error, let's stick to creating it explicitly here
        # to ensure it's linked correctly.
        ttk.Label(self.input_frame, text="Laenu kestus (aastates):").grid(row=row, column=0, sticky="w", padx=5, pady=2)
        # Create the entry and LINK IT TO the StringVar initialized in __init__
        loan_years_entry = ttk.Entry(self.input_frame, textvariable=self.loan_years) # Link the StringVar
        # The default value is already set on the StringVar in __init__
        loan_years_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)
        # Optional: Store this specific entry widget if needed elsewhere
        # self.entries["duration_entry"] = loan_years_entry
        row += 1
        # --- End Loan Duration Handling ---


        # Use helper for remaining rows
        self._add_input_row("Laenu aastaintress (%):", self.sv_annual_rate, row); row += 1
        self._add_input_row("ETFi investeeringu algsumma (€):", self.sv_etf_initial, row); row += 1
        self._add_input_row("ETFi kasvuprotsent sts.2 (%):", self.sv_etf_growth_full, row); row += 1
        self._add_input_row("ETFi kasvuprotsent sts.3 (%):", self.sv_etf_growth_div, row); row += 1
        self._add_input_row("ETFi dividendimäär (%):", self.sv_etf_dividend, row); row += 1


        # Scenario selection checkboxes
        ttk.Label(self.input_frame, text="Vali stsenaarium(id):").grid(row=row, column=0, sticky="w", padx=5, pady=5)
        self.scenario1_var = tk.IntVar(value=1) # Set defaults
        self.scenario2_var = tk.IntVar(value=1)
        self.scenario3_var = tk.IntVar(value=1)
        cb_frame = ttk.Frame(self.input_frame)
        cb_frame.grid(row=row, column=1, sticky="w")
        ttk.Checkbutton(cb_frame, text="1: Laenu vähendamine", variable=self.scenario1_var).pack(anchor="w")
        ttk.Checkbutton(cb_frame, text="2: ETF reinvesteerimine", variable=self.scenario2_var).pack(anchor="w")
        ttk.Checkbutton(cb_frame, text="3: ETF dividendidega laenu vähendamine -> Reinvest.", variable=self.scenario3_var).pack(anchor="w") # Updated text slightly
        row += 1

        # Display option radio buttons
        ttk.Label(self.input_frame, text="Tulemuste kuvamine:").grid(row=row, column=0, sticky="w", padx=5, pady=5)
        self.display_option_var = tk.IntVar(value=1) # Default to final result
        rb_frame = ttk.Frame(self.input_frame)
        rb_frame.grid(row=row, column=1, sticky="w")
        ttk.Radiobutton(rb_frame, text="Lõpptulemus", variable=self.display_option_var, value=1).pack(anchor="w")
        ttk.Radiobutton(rb_frame, text="Aastad 1,5,10,20,30", variable=self.display_option_var, value=2).pack(anchor="w")
        ttk.Radiobutton(rb_frame, text="Iga aasta", variable=self.display_option_var, value=3).pack(anchor="w")
        row += 1

        # Action buttons
        action_frame = ttk.Frame(self.input_frame)
        action_frame.grid(row=row, column=0, columnspan=2, pady=10)
        self.btn_calculate = ttk.Button(action_frame, text="Calculate", command=self.calculate)
        self.btn_calculate.pack(side=tk.LEFT, padx=5)
        self.btn_new_calc = ttk.Button(action_frame, text="New Calculation", command=self.new_calculation)
        self.btn_new_calc.pack(side=tk.LEFT, padx=5)
        self.btn_save_results = ttk.Button(action_frame, text="Save Results", command=self.save_results_ui, state=tk.DISABLED) # Disabled initially
        self.btn_save_results.pack(side=tk.LEFT, padx=5)


    def create_output_widgets(self):
        """Creates the text area and graph frame for output."""
        # Text Results Area with Scrollbar
        text_frame = ttk.Frame(self.output_frame)
        text_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        text_frame.rowconfigure(0, weight=1)
        text_frame.columnconfigure(0, weight=1)

        self.text_results = tk.Text(text_frame, height=10, width=80, wrap="none", borderwidth=0) # Use wrap="none" with scrollbars
        text_scrollbar_y = ttk.Scrollbar(text_frame, orient="vertical", command=self.text_results.yview)
        text_scrollbar_x = ttk.Scrollbar(text_frame, orient="horizontal", command=self.text_results.xview)
        self.text_results.configure(yscrollcommand=text_scrollbar_y.set, xscrollcommand=text_scrollbar_x.set)

        self.text_results.grid(row=0, column=0, sticky="nsew")
        text_scrollbar_y.grid(row=0, column=1, sticky="ns")
        text_scrollbar_x.grid(row=1, column=0, sticky="ew")

        # Graph Area Frame
        self.graph_frame = ttk.Frame(self.output_frame)
        self.graph_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        # The matplotlib canvas will be packed into this frame later

    def _get_float_input(self, string_var: tk.StringVar, label_text: str) -> float:
        """Safely gets and converts value from a StringVar to float, providing label text for errors."""
        try:
            # Get value from StringVar and replace comma with dot for European number format
            value_str = string_var.get().replace(',', '.')
            return float(value_str)
        except ValueError:
            # Use the provided label_text in the error message
            raise ValueError(f"Vigane sisend väljal '{label_text}': Palun sisesta number.")
        except Exception as e:
             # Catch any other unexpected error during get() or replace()
             raise ValueError(f"Viga sisendi lugemisel väljal '{label_text}': {e}")


    def calculate(self):
        """Performs the simulation calculations based on inputs."""
        self.new_calculation() # Clear previous results first

        try:
            # Read inputs using helper function and explicit StringVar access
            prop0 = self._get_float_input(self.sv_prop0, "Kinnisvara algväärtus")
            prop_growth = self._get_float_input(self.sv_prop_growth, "Kinnisvara aastane kasv")
            init_own = self._get_float_input(self.sv_init_own, "Sissemakstud omafinantseering")
            add_own = self._get_float_input(self.sv_add_own, "Lisatud omafinantseering")

            # --- Read Loan Duration Separately from its specific StringVar ---
            loan_duration_str = self.loan_years.get().replace(',', '.') # Get from StringVar and handle comma
            try:
                 loan_duration = float(loan_duration_str)
            except ValueError:
                 # Handle error specifically for loan duration using its label
                 raise ValueError("Vigane sisend väljal 'Laenu kestus (aastates)': Palun sisesta number.")
            # --- End Loan Duration Reading ---

            annual_rate = self._get_float_input(self.sv_annual_rate, "Laenu aastaintress")
            etf_initial = self._get_float_input(self.sv_etf_initial, "ETFi investeeringu algsumma")
            etf_growth_full = self._get_float_input(self.sv_etf_growth_full, "ETFi kasvuprotsent sts.2")
            etf_growth_div = self._get_float_input(self.sv_etf_growth_div, "ETFi kasvuprotsent sts.3")
            etf_dividend = self._get_float_input(self.sv_etf_dividend, "ETFi dividendimäär")


            # Validate inputs (basic examples)
            if loan_duration <= 0 or not float(loan_duration).is_integer(): # Ensure positive integer duration
                raise ValueError("Laenu kestus peab olema positiivne täisarv.")
            if prop0 <= 0 : raise ValueError("Kinnisvara algväärtus peab olema positiivne.")
            if annual_rate < 0 : raise ValueError("Laenu aastaintress ei saa olla negatiivne.")
            if etf_growth_full < -100 or etf_growth_div < -100 : raise ValueError("ETF kasvuprotsent ei saa olla väiksem kui -100%.")
            if etf_dividend < 0 : raise ValueError("ETFi dividendimäär ei saa olla negatiivne.")
            # Add more validations as needed

            full_loan = prop0 - init_own - PROCESSING_FEE
            if full_loan < 0:
                 messagebox.showwarning("Hoiatus", f"Arvutatud laenusumma ({full_loan:,.0f}€) on negatiivne (omafinantseering + tasu > vara väärtus). Laenuks seatakse 0€.".replace(",", " ")) # Corrected message slightly
                 full_loan = 0.0

        except ValueError as e:
            messagebox.showerror("Sisendviga", str(e))
            return
        except Exception as e: # Catch unexpected errors during input processing
             messagebox.showerror("Viga", f"Ootamatu viga sisendite lugemisel: {e}")
             traceback.print_exc() # Print traceback for unexpected errors
             return

        selected_scenarios: List[Tuple[str, ScenarioResults]] = []
        try:
            # Pass the converted numeric loan_duration to simulation functions
            if self.scenario1_var.get() == 1:
                res1 = simulate_scenario_1(loan_duration, prop0, prop_growth, full_loan, add_own, annual_rate)
                if res1: selected_scenarios.append(("Stsenaarium 1", res1)) # Add only if results generated
            if self.scenario2_var.get() == 1:
                res2 = simulate_scenario_2(loan_duration, prop0, prop_growth, full_loan, annual_rate, etf_initial, etf_growth_full, etf_dividend)
                if res2: selected_scenarios.append(("Stsenaarium 2", res2))
            if self.scenario3_var.get() == 1:
                res3 = simulate_scenario_3(loan_duration, prop0, prop_growth, full_loan, annual_rate, etf_initial, etf_growth_div, etf_dividend)
                if res3: selected_scenarios.append(("Stsenaarium 3", res3))

        except Exception as e: # Catch errors during simulation
             messagebox.showerror("Simulatsiooni Viga", f"Viga arvutuste käigus: {e}")
             traceback.print_exc() # Print traceback for simulation errors
             return

        if not selected_scenarios:
            self.text_results.configure(state='normal') # Make editable to insert message
            self.text_results.insert(tk.END, "Palun vali vähemalt üks stsenaarium ja kontrolli sisendeid.\nÜhtegi tulemust ei genereeritud.\n")
            self.text_results.configure(state='disabled') # Make read-only again
            return

        # Store results for saving (only if calculation succeeded and results exist)
        self.session_results = {name: copy.deepcopy(results_list) for name, results_list in selected_scenarios}

        # Display results
        # display_results still needs the *string* value of loan_years for target years logic
        # It gets this from self.loan_years.get(), which is correct.
        self.display_results(selected_scenarios)
        # Plot results
        self.plot_results(selected_scenarios)
        # Enable save button only after successful calculation
        self.btn_save_results.config(state=tk.NORMAL)


    def display_results(self, scenario_data: List[Tuple[str, List[SimulationResult]]]):
        """Formats and displays the simulation results in the text area."""
        display_option = self.display_option_var.get()
        output_text = ""

        # Define headers and format string (add Gross Dividend, adjust spacing)
        headers = ["Aasta", "Kinn.Väärtus", "Laenujääk", "Kuumakse", "Aastaintress", "ETF Väärtus", "ETF Kasv", "Gross Div.", "Neto Omakapital"]
        # Adjust spacing - this might require some trial and error based on expected value ranges
        fmt = "{:<6} {:>15} {:>15} {:>12} {:>15} {:>15} {:>12} {:>12} {:>18}\n"
        header_line = fmt.format(*headers)
        separator = "-" * (len(header_line.rstrip())) + "\n" # Adjust separator length to content

        if display_option in [2, 3]: # Table view (Specific years or All years)
            for name, results_list in scenario_data:
                if not results_list: continue # Skip if a scenario yielded no results
                output_text += f"\n{name}:\n" + header_line + separator # Add newline before scenario
                # Get total interest from the last entry if available
                total_interest = results_list[-1].TotalInterest if results_list and results_list[-1].TotalInterest is not None else 0.0

                years_in_results = {r.Year for r in results_list}

                # --- Determine target years for display ---
                # Access the string value from the Tkinter variable self.loan_years
                loan_years_str = self.loan_years.get() # Use .get() to get the value

                loan_term_int = 0 # Default if loan_years_str is empty or invalid
                # Now check the string value obtained from .get()
                if loan_years_str:
                    try:
                        # Convert the non-empty string value to an integer
                        # Use float first to handle potential decimals like "15.0" from the input
                        loan_term_int = int(float(loan_years_str))
                    except (ValueError, TypeError):
                        # Handle case where the string value could not be converted
                        print(f"Warning: Could not convert loan term '{loan_years_str}' to integer for display years.")
                        pass # Keep loan_term_int as 0

                # Start with standard target years plus the entered loan term year
                target_years = {1, 5, 10, 20}
                if loan_term_int > 0:
                    target_years.add(loan_term_int) # Add the entered loan duration year

                # Ensure the last actual year in the results is always included
                if results_list:
                    target_years.add(results_list[-1].Year)

                # --- Select rows to show based on display option ---
                if display_option == 2: # Specific years
                     # Show years from target_years that actually exist in the results
                    years_to_show = sorted(years_in_results.intersection(target_years))
                    # Ensure last year is definitely shown if available, even if not in initial targets
                    if results_list and results_list[-1].Year not in years_to_show:
                         years_to_show.append(results_list[-1].Year)
                         years_to_show = sorted(years_to_show) # Re-sort if last year was added

                    rows_to_show = [r for r in results_list if r.Year in years_to_show]

                else: # display_option == 3: All years
                    rows_to_show = results_list

                # --- Format and append rows to output_text ---
                for r in rows_to_show:
                    # Use space as thousand separator for Estonian locale consistency
                    output_text += fmt.format(
                        r.Year,
                        f"{r.PropertyValue:,.0f}".replace(",", " "),
                        f"{r.LoanBalance:,.0f}".replace(",", " "),
                        f"{r.MonthlyPayment:,.0f}".replace(",", " "),
                        f"{r.AnnualInterest:,.0f}".replace(",", " "),
                        f"{r.ETFValue:,.0f}".replace(",", " "),
                        f"{r.ETFGrowth:,.0f}".replace(",", " "),
                        f"{r.GrossDividend:,.0f}".replace(",", " "), # Add Gross Dividend
                        f"{r.NetEquity:,.0f}".replace(",", " ")
                    )
                # Footer with Total Interest
                output_text += separator
                total_interest_str = f"{total_interest:,.0f}".replace(",", " ") if total_interest is not None else "N/A"
                # Format the footer row - putting total interest under the correct column
                # The footer doesn't have data for most columns, pass empty strings
                footer_cols = ["Kokku", "", "", "", total_interest_str, "", "", "", ""]
                output_text += fmt.format(*footer_cols)
                output_text += "\n"

        else: # Display option 1: Final result only
            for name, results_list in scenario_data:
                if not results_list: continue
                last = results_list[-1]
                total_interest = last.TotalInterest if last.TotalInterest is not None else 0.0
                # Use space separator for locale
                output_text += f"{name} - Lõpptulemus (aasta {last.Year}):\n"
                output_text += f"  Kinnisvara Väärtus: {last.PropertyValue:,.2f} €\n".replace(",", " ")
                output_text += f"  Laenujääk: {last.LoanBalance:,.2f} €\n".replace(",", " ")
                output_text += f"  Kuumakse (viimane): {last.MonthlyPayment:,.2f} €/kuu\n".replace(",", " ")
                output_text += f"  ETF Väärtus: {last.ETFValue:,.2f} €\n".replace(",", " ")
                f"  ETF Kasv (viimane aasta): {last.ETFGrowth:,.2f} €\n".replace(",", " ")
                output_text += f"  Gross Dividend (viimane aasta): {last.GrossDividend:,.2f} €\n".replace(",", " ") # Add Gross Dividend line
                output_text += f"  Neto Omakapital: {last.NetEquity:,.2f} €\n".replace(",", " ")
                output_text += "----------------------------------------\n"
                total_interest_str = f"{total_interest:,.2f} €".replace(",", " ") if total_interest is not None else "N/A"
                output_text += f"  Koguintress Perioodi Jooksul: {total_interest_str}\n\n"

        # Clear previous results before inserting new ones
        self.text_results.configure(state='normal') # Ensure text widget is editable
        self.text_results.delete("1.0", tk.END)
        self.text_results.insert(tk.END, output_text)
        self.text_results.configure(state='disabled') # Make read-only after update


    def plot_results(self, scenario_data: List[Tuple[str, List[SimulationResult]]]):
        """Plots the results on the Matplotlib canvas."""
        # Clear previous graph
        for widget in self.graph_frame.winfo_children():
            widget.destroy()

        if not any(res for _, res in scenario_data): # Check if there's any data to plot
             ttk.Label(self.graph_frame, text="Graafikute kuvamiseks puuduvad andmed.").pack(padx=10, pady=10)
             return

        # Ensure figure and axes are created on each call to avoid state issues
        fig, axs = plt.subplots(3, 1, figsize=(8, 8), sharex=True, constrained_layout=True) # Use constrained_layout

        all_etf_growth_values = [] # To set y-limit for ETF growth plot
        all_years_simulated = [] # To set consistent x-axis limits

        for name, results_list in scenario_data:
            if not results_list: continue # Skip empty results
            years = [r.Year for r in results_list]
            loan_balances = [r.LoanBalance for r in results_list]
            net_equities = [r.NetEquity for r in results_list]
            etf_growths = [r.ETFGrowth for r in results_list] # Plotting capital growth part

            all_years_simulated.extend(years)
            all_etf_growth_values.extend(etf_growths)

            axs[0].plot(years, loan_balances, marker=".", linestyle='-', label=name)
            axs[1].plot(years, net_equities, marker=".", linestyle='-', label=name)
            axs[2].plot(years, etf_growths, marker=".", linestyle='-', label=name)

        # --- Formatting Axes ---
        axs[0].set_title("Laenujääk Aastate Jooksul")
        axs[0].set_ylabel("Laenujääk (€)")
        axs[0].ticklabel_format(style='plain', axis='y') # Avoid scientific notation
        axs[0].yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',').replace(",", " "))) # Space separator
        axs[0].legend()
        axs[0].grid(True, linestyle='--', alpha=0.6)

        axs[1].set_title("Neto Omakapital Aastate Jooksul")
        axs[1].set_ylabel("Neto Omakapital (€)")
        axs[1].ticklabel_format(style='plain', axis='y')
        axs[1].yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',').replace(",", " ")))
        axs[1].legend()
        axs[1].grid(True, linestyle='--', alpha=0.6)

        axs[2].set_title("Aastane ETF Kapitalikasv") # Title reflects ETFGrowth field
        axs[2].set_xlabel("Aasta")
        axs[2].set_ylabel("Kapitalikasv (€)")
        axs[2].ticklabel_format(style='plain', axis='y')
        axs[2].yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',').replace(",", " ")))
        axs[2].legend()
        axs[2].grid(True, linestyle='--', alpha=0.6)

        # Adjust ETF growth y-axis limits slightly
        if all_etf_growth_values:
            min_growth = min(all_etf_growth_values)
            max_growth = max(all_etf_growth_values)
            if abs(max_growth - min_growth) < 1e-6 : # Handle all same values (inc. zero)
                 axs[2].set_ylim(min_growth - 1, max_growth + 1) # Small fixed padding
            else:
                padding = (max_growth - min_growth) * 0.05 # 5% padding
                axs[2].set_ylim(min_growth - padding, max_growth + padding)
        else:
             # If no ETF growth data, set a default y-limit
             axs[2].set_ylim(-1000, 1000)


        # Set x-axis limits based on actual years plotted
        if all_years_simulated:
            min_year = min(all_years_simulated)
            max_year = max(all_years_simulated)
            # Ensure x-axis ticks are integers
            axs[2].xaxis.set_major_locator(plt.MaxNLocator(integer=True))
            # Add some padding to x-axis
            axs[2].set_xlim(min_year - 0.5, max_year + 0.5)


        # --- Embed Canvas ---
        canvas = FigureCanvasTkAgg(fig, master=self.graph_frame)
        canvas.draw()
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # Optional: Add Matplotlib toolbar for interactivity
        # from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
        # toolbar = NavigationToolbar2Tk(canvas, self.graph_frame, pack_toolbar=False) # Don't pack automatically
        # toolbar.update()
        # toolbar.pack(side=tk.BOTTOM, fill=tk.X) # Pack below canvas


    def new_calculation(self):
        """Clears the output areas and resets session results."""
        # Clear text results
        self.text_results.configure(state='normal')
        self.text_results.delete("1.0", tk.END)
        self.text_results.configure(state='disabled')

        # Clear graph area
        for widget in self.graph_frame.winfo_children():
            widget.destroy()

        # Reset session results
        self.session_results = {}
        self.btn_save_results.config(state=tk.DISABLED) # Disable save button

        # Optional: Reset input fields to default values if desired
        # self.sv_prop0.set(DEFAULT_PROP_VALUE)
        # self.sv_prop_growth.set(DEFAULT_PROP_GROWTH)
        # ... etc.

    def save_results_ui(self):
        """
        Prompts user for filename and saves full simulation results for all
        calculated scenarios to a single CSV file. Includes a 'Total' row per scenario.
        """
        if not self.session_results:
             messagebox.showwarning("Salvestamine", "Arvutustulemused puuduvad. Palun käivita 'Calculate' enne salvestamist.")
             return

        # Suggest filename based on current date (optional)
        # import datetime
        # today = datetime.date.today().strftime("%Y%m%d")
        # initial_filename = f"laenu_simulatsioon_{today}.csv"
        initial_filename = "laenu_investeeringu_simulatsioon.csv"


        file_path = filedialog.asksaveasfilename(
            initialfile=initial_filename,
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Salvesta simulatsiooni tulemused"
        )

        if not file_path:
            # User cancelled
            # Optionally add message back to text_results?
            # self.text_results.configure(state='normal')
            # self.text_results.insert(tk.END, "\nFaili salvestamine tühistatud.\n")
            # self.text_results.configure(state='disabled')
            return

        combined_rows: List[Dict[str, Any]] = []
        # Define fieldnames based on SimulationResult + Scenario name
        # Ensure TotalInterest is excluded from yearly rows as it's handled by the summary row
        # Order fields logically for CSV output
        fieldnames = ["Scenario", "Year", "PropertyValue", "LoanBalance", "MonthlyPayment",
                      "AnnualInterest", "ETFValue", "ETFGrowth", "GrossDividend",
                      "DividendIncome", "NetEquity"]

        for scenario_name, results_list in self.session_results.items():
            if not results_list: continue
            # Safely get total_interest from the last entry
            total_interest = results_list[-1].TotalInterest if results_list and results_list[-1].TotalInterest is not None else 0.0


            for r in results_list:
                row_dict = asdict(r)
                row_dict["Scenario"] = scenario_name
                # Round numeric values intended for CSV output
                for key, value in row_dict.items():
                    if isinstance(value, (int, float)):
                        # Round to 0 decimal places for currency/large values
                        # Keep 2 for rates if they were included, but they aren't here
                         row_dict[key] = round(value) # Using 0 decimal places

                # Filter out TotalInterest field before adding to list
                row_dict.pop("TotalInterest", None)
                combined_rows.append(row_dict)

            # Append the extra 'Total' row for this scenario's interest
            # This row will only have 'Scenario', 'Year' (as "Total"), and 'AnnualInterest' (as total_interest)
            combined_rows.append({
                "Scenario": scenario_name,
                "Year": "Total",
                "PropertyValue": "",
                "LoanBalance": "",
                "MonthlyPayment": "",
                # Place total interest under the AnnualInterest column
                "AnnualInterest": round(total_interest) if total_interest is not None else "",
                "ETFValue": "",
                "ETFGrowth": "",
                "GrossDividend": "",
                "DividendIncome": "",
                "NetEquity": ""
            })

        try:
            # Use DictWriter, handle missing keys gracefully with default ""
            # Ensure correct delimiter if locale uses comma for decimal (use semicolon for CSV)
            # Estonian locale typically uses comma decimal, so semicolon CSV is better
            with open(file_path, mode="w", newline="", encoding="utf-8-sig") as csvfile: # utf-8-sig for Excel BOM
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames, restval="", extrasaction='ignore', delimiter=';')
                writer.writeheader()
                for row_data in combined_rows:
                     # Ensure only defined fieldnames are written
                    row_to_write = {field: row_data.get(field, "") for field in fieldnames}
                    writer.writerow(row_to_write)

            # Add confirmation to text widget and show message box
            self.text_results.configure(state='normal')
            self.text_results.insert(tk.END, f"\nTulemused salvestatud faili:\n{file_path}\n")
            self.text_results.configure(state='disabled')
            messagebox.showinfo("Salvestamine õnnestus", f"Tulemused salvestati faili:\n{file_path}")

        except (IOError, PermissionError, csv.Error) as e:
            error_msg = f"Salvestamise viga faili {file_path}:\n{e}\n\nVeendu, et fail pole avatud teises programmis ja sul on kausta kirjutusõigus."
            messagebox.showerror("Salvestamise Viga", error_msg)
        except Exception as e: # Catch any other unexpected errors
            error_msg = f"Ootamatu viga salvestamisel:\n{e}"
            traceback.print_exc() # Log for debugging
            messagebox.showerror("Salvestamise Viga", error_msg)


# -----------------------------
# MAIN APPLICATION ENTRY POINT
# -----------------------------
if __name__ == "__main__":
    root = tk.Tk()

    # --- Style and Font Configuration ---
    style = ttk.Style()
    try:
        # Try a theme known to exist on major platforms
        if 'clam' in style.theme_names():
            style.theme_use('clam')
        elif 'vista' in style.theme_names(): # Windows
             style.theme_use('vista')
        elif 'aqua' in style.theme_names(): # macOS
             style.theme_use('aqua')
        # else fallback to default
    except tk.TclError:
        print("Could not set preferred theme, using default.")

    default_font = tkfont.nametofont("TkDefaultFont")
    font_size = default_font.cget("size")
    # Set font size (adjust multiplier as needed)
    new_size = max(10, int(font_size * 1.1)) # Ensure minimum size 10
    default_font.configure(size=new_size)
    # Apply default font more broadly
    root.option_add("*Font", default_font)
    # Ensure specific ttk widget types use the font if needed
    style.configure("TLabel", font=default_font)
    style.configure("TButton", font=default_font)
    style.configure("TCheckbutton", font=default_font)
    style.configure("TRadiobutton", font=default_font)
    style.configure("TEntry", font=default_font)
    style.configure("TLabelFrame.Label", font=default_font) # For LabelFrame titles


    # Set a reasonable minimum size
    root.minsize(750, 600) # Increased min size slightly for new column

    app = LoanDecisionGUI(root)
    root.mainloop()